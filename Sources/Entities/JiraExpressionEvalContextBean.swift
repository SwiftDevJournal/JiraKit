// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import NaiveDate

public struct JiraExpressionEvalContextBean: Codable {
    /// The issue that is available under the `issue` variable when evaluating the expression.
    public var issue: IDOrKeyBean?
    /// The collection of issues that is available under the `issues` variable when evaluating the expression.
    public var issues: JexpIssues?
    /// The project that is available under the `project` variable when evaluating the expression.
    public var project: IDOrKeyBean?
    /// The ID of the sprint that is available under the `sprint` variable when evaluating the expression.
    public var sprint: Int?
    /// The ID of the board that is available under the `board` variable when evaluating the expression.
    public var board: Int?
    /// The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression.
    public var serviceDesk: Int?
    /// The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type.
    public var customerRequest: Int?
    /// Custom context variables and their types. These variable types are available for use in a custom context:
    /// 
    ///  *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
    ///  *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
    ///  *  `json`: A JSON object containing custom content.
    ///  *  `list`: A JSON list of `user`, `issue`, or `json` variable types.
    public var custom: [CustomContextVariable]?

    public init(issue: IDOrKeyBean? = nil, issues: JexpIssues? = nil, project: IDOrKeyBean? = nil, sprint: Int? = nil, board: Int? = nil, serviceDesk: Int? = nil, customerRequest: Int? = nil, custom: [CustomContextVariable]? = nil) {
        self.issue = issue
        self.issues = issues
        self.project = project
        self.sprint = sprint
        self.board = board
        self.serviceDesk = serviceDesk
        self.customerRequest = customerRequest
        self.custom = custom
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.issue = try values.decodeIfPresent(IDOrKeyBean.self, forKey: "issue")
        self.issues = try values.decodeIfPresent(JexpIssues.self, forKey: "issues")
        self.project = try values.decodeIfPresent(IDOrKeyBean.self, forKey: "project")
        self.sprint = try values.decodeIfPresent(Int.self, forKey: "sprint")
        self.board = try values.decodeIfPresent(Int.self, forKey: "board")
        self.serviceDesk = try values.decodeIfPresent(Int.self, forKey: "serviceDesk")
        self.customerRequest = try values.decodeIfPresent(Int.self, forKey: "customerRequest")
        self.custom = try values.decodeIfPresent([CustomContextVariable].self, forKey: "custom")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(issue, forKey: "issue")
        try values.encodeIfPresent(issues, forKey: "issues")
        try values.encodeIfPresent(project, forKey: "project")
        try values.encodeIfPresent(sprint, forKey: "sprint")
        try values.encodeIfPresent(board, forKey: "board")
        try values.encodeIfPresent(serviceDesk, forKey: "serviceDesk")
        try values.encodeIfPresent(customerRequest, forKey: "customerRequest")
        try values.encodeIfPresent(custom, forKey: "custom")
    }
}
