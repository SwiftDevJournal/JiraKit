// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.API.__3.Issue {
    public func issueIDOrKey(_ issueIDOrKey: String) -> WithIssueIDOrKey {
        WithIssueIDOrKey(path: "\(path)/\(issueIDOrKey)")
    }

    public struct WithIssueIDOrKey {
        /// Path: `/rest/api/3/issue/{issueIdOrKey}`
        public let path: String

        /// Get issue
        ///
        /// Returns the details for an issue.
        /// 
        /// The issue is identified by its ID or key, however, if the identifier doesn't match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.
        /// 
        /// This operation can be accessed anonymously.
        /// 
        /// **[Permissions](#permissions) required:**
        /// 
        ///  *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
        ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        public func get(parameters: GetParameters? = nil) -> Request<JiraKit.IssueBean> {
            Request(path: path, method: "GET", query: parameters?.asQuery, id: "getIssue")
        }

        public struct GetParameters {
            public var fields: [String]?
            public var isFieldsByKeys: Bool?
            public var expand: String?
            public var properties: [String]?
            public var isUpdateHistory: Bool?

            public init(fields: [String]? = nil, isFieldsByKeys: Bool? = nil, expand: String? = nil, properties: [String]? = nil, isUpdateHistory: Bool? = nil) {
                self.fields = fields
                self.isFieldsByKeys = isFieldsByKeys
                self.expand = expand
                self.properties = properties
                self.isUpdateHistory = isUpdateHistory
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields")
                encoder.encode(isFieldsByKeys, forKey: "fieldsByKeys")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(properties, forKey: "properties")
                encoder.encode(isUpdateHistory, forKey: "updateHistory")
                return encoder.items
            }
        }

        /// Edit issue
        ///
        /// Edits an issue. A transition may be applied and issue properties updated as part of the edit.
        /// 
        /// The edits to the issue's fields are defined using `update` and `fields`. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-3-issue-issueIdOrKey-editmeta-get).
        /// 
        /// The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting `update.parent.set.none` to *true*. Note that the `description`, `environment`, and any `textarea` type custom fields (multi-line text fields) take Atlassian Document Format content. Single line custom fields (`textfield`) accept a string and don't handle Atlassian Document Format content.
        /// 
        /// Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using `overrideScreenSecurity` and `overrideEditableFlag`.
        /// 
        /// This operation can be accessed anonymously.
        /// 
        /// **[Permissions](#permissions) required:**
        /// 
        ///  *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.
        ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        public func put(parameters: PutParameters? = nil, _ body: JiraKit.IssueUpdateDetails) -> Request<AnyJSON> {
            Request(path: path, method: "PUT", query: parameters?.asQuery, body: body, id: "editIssue")
        }

        public struct PutParameters {
            public var isNotifyUsers: Bool?
            public var isOverrideScreenSecurity: Bool?
            public var isOverrideEditableFlag: Bool?

            public init(isNotifyUsers: Bool? = nil, isOverrideScreenSecurity: Bool? = nil, isOverrideEditableFlag: Bool? = nil) {
                self.isNotifyUsers = isNotifyUsers
                self.isOverrideScreenSecurity = isOverrideScreenSecurity
                self.isOverrideEditableFlag = isOverrideEditableFlag
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isNotifyUsers, forKey: "notifyUsers")
                encoder.encode(isOverrideScreenSecurity, forKey: "overrideScreenSecurity")
                encoder.encode(isOverrideEditableFlag, forKey: "overrideEditableFlag")
                return encoder.items
            }
        }

        /// Delete issue
        ///
        /// Deletes an issue.
        /// 
        /// An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set `deleteSubtasks`. This causes the issue's subtasks to be deleted with the issue.
        /// 
        /// This operation can be accessed anonymously.
        /// 
        /// **[Permissions](#permissions) required:**
        /// 
        ///  *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.
        ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        public func delete(deleteSubtasks: DeleteSubtasks? = nil) -> Request<Void> {
            Request(path: path, method: "DELETE", query: makeDeleteQuery(deleteSubtasks), id: "deleteIssue")
        }

        private func makeDeleteQuery(_ deleteSubtasks: DeleteSubtasks?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(deleteSubtasks, forKey: "deleteSubtasks")
            return encoder.items
        }

        public enum DeleteSubtasks: String, Codable, CaseIterable {
            case `true`
            case `false`
        }
    }
}
